{"version":3,"file":"main-DdIQL5nF.js","sources":["../../src/types/index.ts","../../src/utils/youtube.ts","../../src/utils/storage.ts","../../src/player/YouTubeMusicPlayer.ts","../../index.html?html-proxy&index=1.js"],"sourcesContent":["// YouTube Player API Types\nexport interface YTPlayer {\n  playVideo(): void;\n  pauseVideo(): void;\n  stopVideo(): void;\n  seekTo(seconds: number, allowSeekAhead?: boolean): void;\n  getCurrentTime(): number;\n  getDuration(): number;\n  getPlayerState(): PlayerState;\n  getVolume(): number;\n  setVolume(volume: number): void;\n  mute(): void;\n  unMute(): void;\n  isMuted(): boolean;\n  loadVideoById(videoId: string, startSeconds?: number, suggestedQuality?: string): void;\n  cueVideoById(videoId: string, startSeconds?: number, suggestedQuality?: string): void;\n  getVideoUrl(): string;\n  getVideoEmbedCode(): string;\n  addEventListener(event: string, listener: string): void;\n  removeEventListener(event: string, listener: string): void;\n  destroy(): void;\n}\n\n// Player State Enum\nexport enum PlayerState {\n  UNSTARTED = -1,\n  ENDED = 0,\n  PLAYING = 1,\n  PAUSED = 2,\n  BUFFERING = 3,\n  CUED = 5,\n}\n\n// Repeat Mode Enum\nexport enum RepeatMode {\n  NONE = 'none',\n  ONE = 'one',\n  ALL = 'all',\n}\n\n// Track Interface\nexport interface Track {\n  id: string;\n  title: string;\n  artist?: string;\n  tags?: string[];\n  duration: number;\n  thumbnail?: string;\n  url: string;\n  addedAt: Date;\n}\n\n// Playlist Interface\nexport interface Playlist {\n  tracks: Track[];\n  currentIndex: number;\n  shuffled: boolean;\n  shuffleOrder?: number[];\n}\n\n// Player Settings Interface\nexport interface PlayerSettings {\n  volume: number;\n  repeatMode: RepeatMode;\n  shuffled: boolean;\n  autoplay: boolean;\n}\n\n// Player State Interface\nexport interface PlayerStateData {\n  playlist: Playlist;\n  currentTime: number;\n  settings: PlayerSettings;\n  lastUpdated: Date;\n}\n\n// Event Types\nexport type PlayerEventType =\n  | 'ready'\n  | 'stateChange'\n  | 'trackChange'\n  | 'playlistChange'\n  | 'error'\n  | 'timeUpdate'\n  | 'volumeChange'\n  | 'settingsChange';\n\n// Event Handler Type\nexport type EventHandler<T = any> = (data: T) => void;\n\n// Player Configuration\nexport interface PlayerConfig {\n  containerId: string;\n  autoplay?: boolean;\n  volume?: number;\n  repeat?: RepeatMode;\n  shuffle?: boolean;\n  enableKeyboardShortcuts?: boolean;\n  saveState?: boolean;\n  storageKey?: string;\n}\n\n// YouTube Video Info\nexport interface VideoInfo {\n  id: string;\n  title: string;\n  duration: number;\n  thumbnail: string;\n  channelTitle?: string;\n}\n\n// Error Types\nexport enum ErrorType {\n  INVALID_VIDEO_ID = 'INVALID_VIDEO_ID',\n  VIDEO_NOT_FOUND = 'VIDEO_NOT_FOUND',\n  VIDEO_NOT_EMBEDDABLE = 'VIDEO_NOT_EMBEDDABLE',\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  API_ERROR = 'API_ERROR',\n  STORAGE_ERROR = 'STORAGE_ERROR',\n}\n\n// Player Error Interface\nexport interface PlayerError {\n  type: ErrorType;\n  message: string;\n  videoId?: string;\n  originalError?: any;\n}\n\n// URL Validation Result\nexport interface URLValidationResult {\n  isValid: boolean;\n  videoId?: string;\n  error?: string;\n}\n\n// Storage Interface\nexport interface StorageManager {\n  save(key: string, data: any): void;\n  load<T>(key: string): T | null;\n  remove(key: string): void;\n  clear(): void;\n}\n\n// YouTube API Load State\nexport interface YouTubeAPIState {\n  loaded: boolean;\n  loading: boolean;\n  error?: string;\n}\n\n// Player Options for YouTube IFrame API\nexport interface YouTubePlayerOptions {\n  height: string | number;\n  width: string | number;\n  videoId?: string;\n  playerVars?: {\n    autoplay?: 0 | 1;\n    controls?: 0 | 1;\n    disablekb?: 0 | 1;\n    enablejsapi?: 0 | 1;\n    end?: number;\n    fs?: 0 | 1;\n    hl?: string;\n    iv_load_policy?: 1 | 3;\n    list?: string;\n    listType?: 'playlist' | 'user_uploads';\n    loop?: 0 | 1;\n    modestbranding?: 0 | 1;\n    origin?: string;\n    playlist?: string;\n    playsinline?: 0 | 1;\n    rel?: 0 | 1;\n    start?: number;\n    widget_referrer?: string;\n  };\n  events?: {\n    onReady?: (event: any) => void;\n    onStateChange?: (event: any) => void;\n    onPlaybackQualityChange?: (event: any) => void;\n    onPlaybackRateChange?: (event: any) => void;\n    onError?: (event: any) => void;\n    onApiChange?: (event: any) => void;\n  };\n}\n\n// Global YouTube API types\ndeclare global {\n  interface Window {\n    YT: {\n      Player: new (elementId: string, options: YouTubePlayerOptions) => YTPlayer;\n      PlayerState: typeof PlayerState;\n      ready: (callback: () => void) => void;\n    };\n    onYouTubeIframeAPIReady: () => void;\n  }\n} ","import { URLValidationResult, YouTubeAPIState, ErrorType, PlayerError } from '../types';\n\n/**\n * Extracts YouTube video ID from various URL formats\n */\nexport function extractVideoId(url: string): URLValidationResult {\n  const patterns = [\n    // Standard YouTube URLs\n    /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/)([a-zA-Z0-9_-]{11})/,\n    // YouTube mobile URLs\n    /(?:m\\.youtube\\.com\\/watch\\?v=)([a-zA-Z0-9_-]{11})/,\n    // YouTube shortened URLs with additional parameters\n    /(?:youtu\\.be\\/)([a-zA-Z0-9_-]{11})/,\n    // Direct video ID (11 characters)\n    /^([a-zA-Z0-9_-]{11})$/,\n  ];\n\n  // Clean the URL\n  const cleanUrl = url.trim();\n\n  for (const pattern of patterns) {\n    const match = cleanUrl.match(pattern);\n    if (match && match[1]) {\n      return {\n        isValid: true,\n        videoId: match[1],\n      };\n    }\n  }\n\n  return {\n    isValid: false,\n    error: 'Invalid YouTube URL or Video ID',\n  };\n}\n\n/**\n * Validates if a string is a valid YouTube URL or video ID\n */\nexport function isValidYouTubeUrl(url: string): boolean {\n  return extractVideoId(url).isValid;\n}\n\n/**\n * Generates thumbnail URL for a YouTube video\n */\nexport function getThumbnailUrl(videoId: string, quality: 'default' | 'medium' | 'high' | 'standard' | 'maxres' = 'medium'): string {\n  const qualityMap = {\n    default: 'default',\n    medium: 'mqdefault',\n    high: 'hqdefault',\n    standard: 'sddefault',\n    maxres: 'maxresdefault',\n  };\n\n  return `https://img.youtube.com/vi/${videoId}/${qualityMap[quality]}.jpg`;\n}\n\n/**\n * YouTube API management\n */\nclass YouTubeAPIManager {\n  private state: YouTubeAPIState = {\n    loaded: false,\n    loading: false,\n  };\n\n  private loadPromise: Promise<void> | null = null;\n  private callbacks: (() => void)[] = [];\n\n  /**\n   * Load the YouTube IFrame API\n   */\n  async loadAPI(): Promise<void> {\n    if (this.state.loaded) {\n      return Promise.resolve();\n    }\n\n    if (this.state.loading && this.loadPromise) {\n      return this.loadPromise;\n    }\n\n    this.state.loading = true;\n    this.loadPromise = new Promise((resolve, reject) => {\n      // Check if API is already loaded\n      if (window.YT && window.YT.Player) {\n        this.state.loaded = true;\n        this.state.loading = false;\n        resolve();\n        return;\n      }\n\n      // Set up global callback\n      const originalCallback = window.onYouTubeIframeAPIReady;\n      window.onYouTubeIframeAPIReady = () => {\n        this.state.loaded = true;\n        this.state.loading = false;\n        \n        // Execute any pending callbacks\n        this.callbacks.forEach(callback => callback());\n        this.callbacks = [];\n\n        // Call original callback if it existed\n        if (originalCallback) {\n          originalCallback();\n        }\n\n        resolve();\n      };\n\n      // Create and append script tag\n      const script = document.createElement('script');\n      script.src = 'https://www.youtube.com/iframe_api';\n      script.onerror = () => {\n        this.state.loading = false;\n        this.state.error = 'Failed to load YouTube API';\n        reject(new Error('Failed to load YouTube API'));\n      };\n\n      const firstScript = document.getElementsByTagName('script')[0];\n      if (firstScript && firstScript.parentNode) {\n        firstScript.parentNode.insertBefore(script, firstScript);\n      } else {\n        document.head.appendChild(script);\n      }\n\n      // Timeout after 10 seconds\n      setTimeout(() => {\n        if (this.state.loading) {\n          this.state.loading = false;\n          this.state.error = 'YouTube API load timeout';\n          reject(new Error('YouTube API load timeout'));\n        }\n      }, 10000);\n    });\n\n    return this.loadPromise;\n  }\n\n  /**\n   * Check if API is ready\n   */\n  isReady(): boolean {\n    return this.state.loaded && !!(window.YT && window.YT.Player);\n  }\n\n  /**\n   * Wait for API to be ready\n   */\n  async waitForReady(): Promise<void> {\n    if (this.isReady()) {\n      return Promise.resolve();\n    }\n\n    if (!this.state.loading && !this.state.loaded) {\n      await this.loadAPI();\n    }\n\n    return new Promise((resolve) => {\n      if (this.isReady()) {\n        resolve();\n        return;\n      }\n\n      this.callbacks.push(resolve);\n    });\n  }\n\n  /**\n   * Get current API state\n   */\n  getState(): YouTubeAPIState {\n    return { ...this.state };\n  }\n}\n\n// Singleton instance\nexport const youtubeAPI = new YouTubeAPIManager();\n\n/**\n * Format time in seconds to MM:SS or HH:MM:SS format\n */\nexport function formatTime(seconds: number): string {\n  if (isNaN(seconds) || seconds < 0) {\n    return '0:00';\n  }\n\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n\n  return `${minutes}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Parse time string (MM:SS or HH:MM:SS) to seconds\n */\nexport function parseTime(timeString: string): number {\n  const parts = timeString.split(':').map(part => parseInt(part, 10)).filter(num => !isNaN(num));\n  \n  if (parts.length === 2) {\n    // MM:SS\n    return (parts[0] || 0) * 60 + (parts[1] || 0);\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return (parts[0] || 0) * 3600 + (parts[1] || 0) * 60 + (parts[2] || 0);\n  }\n  \n  return 0;\n}\n\n/**\n * Create a PlayerError from YouTube API error codes\n */\nexport function createPlayerError(errorCode: number, videoId?: string): PlayerError {\n  const errorMap: Record<number, { type: ErrorType; message: string }> = {\n    2: {\n      type: ErrorType.INVALID_VIDEO_ID,\n      message: 'The video ID is invalid or contains invalid characters.',\n    },\n    5: {\n      type: ErrorType.API_ERROR,\n      message: 'The requested content cannot be played in an HTML5 player.',\n    },\n    100: {\n      type: ErrorType.VIDEO_NOT_FOUND,\n      message: 'The video was not found or has been removed.',\n    },\n    101: {\n      type: ErrorType.VIDEO_NOT_EMBEDDABLE,\n      message: 'The video owner does not allow it to be played in embedded players.',\n    },\n    150: {\n      type: ErrorType.VIDEO_NOT_EMBEDDABLE,\n      message: 'The video owner does not allow it to be played in embedded players.',\n    },\n  };\n\n  const errorInfo = errorMap[errorCode] || {\n    type: ErrorType.API_ERROR,\n    message: `Unknown YouTube API error: ${errorCode}`,\n  };\n\n  return {\n    type: errorInfo.type,\n    message: errorInfo.message,\n    ...(videoId && { videoId }),\n    originalError: errorCode,\n  };\n}\n\n/**\n * Generate a random shuffle order for playlist\n */\nexport function generateShuffleOrder(length: number, currentIndex?: number): number[] {\n  const order = Array.from({ length }, (_, i) => i);\n  \n  // Fisher-Yates shuffle\n  for (let i = order.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [order[i], order[j]] = [order[j], order[i]];\n  }\n\n  // If current index is provided, ensure it's first in the shuffle order\n  if (currentIndex !== undefined && currentIndex >= 0 && currentIndex < length) {\n    const currentPos = order.indexOf(currentIndex);\n    if (currentPos > 0) {\n      [order[0], order[currentPos]] = [order[currentPos], order[0]];\n    }\n  }\n\n  return order;\n}\n\n/**\n * Debounce function for limiting API calls\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: number;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = window.setTimeout(() => func(...args), wait);\n  };\n} ","import { StorageManager, PlayerStateData, ErrorType, PlayerError } from '../types';\n\n/**\n * LocalStorage implementation of StorageManager\n */\nexport class LocalStorageManager implements StorageManager {\n  private readonly prefix: string;\n\n  constructor(prefix = 'ytMusicPlayer') {\n    this.prefix = prefix;\n  }\n\n  /**\n   * Save data to localStorage\n   */\n  save(key: string, data: any): void {\n    try {\n      const serialized = JSON.stringify(data);\n      const fullKey = this.getFullKey(key);\n      localStorage.setItem(fullKey, serialized);\n    } catch (error) {\n      console.warn('Failed to save to localStorage:', error);\n      throw new Error(`Storage save failed: ${error}`);\n    }\n  }\n\n  /**\n   * Load data from localStorage\n   */\n  load<T>(key: string): T | null {\n    try {\n      const fullKey = this.getFullKey(key);\n      const item = localStorage.getItem(fullKey);\n      \n      if (item === null) {\n        return null;\n      }\n\n      return JSON.parse(item) as T;\n    } catch (error) {\n      console.warn('Failed to load from localStorage:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove item from localStorage\n   */\n  remove(key: string): void {\n    try {\n      const fullKey = this.getFullKey(key);\n      localStorage.removeItem(fullKey);\n    } catch (error) {\n      console.warn('Failed to remove from localStorage:', error);\n    }\n  }\n\n  /**\n   * Clear all items with the current prefix\n   */\n  clear(): void {\n    try {\n      const keysToRemove: string[] = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(this.prefix + ':')) {\n          keysToRemove.push(key);\n        }\n      }\n      \n      keysToRemove.forEach(key => localStorage.removeItem(key));\n    } catch (error) {\n      console.warn('Failed to clear localStorage:', error);\n    }\n  }\n\n  /**\n   * Check if localStorage is available\n   */\n  isAvailable(): boolean {\n    try {\n      const testKey = '__localStorage_test__';\n      localStorage.setItem(testKey, 'test');\n      localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get storage usage information\n   */\n  getUsageInfo(): { used: number; available: number; percentage: number } {\n    if (!this.isAvailable()) {\n      return { used: 0, available: 0, percentage: 0 };\n    }\n\n    try {\n      // Estimate storage usage\n      let used = 0;\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key) {\n          const value = localStorage.getItem(key);\n          used += key.length + (value?.length || 0);\n        }\n      }\n\n      // Most browsers have ~5-10MB localStorage limit\n      const estimated = 5 * 1024 * 1024; // 5MB\n      const percentage = (used / estimated) * 100;\n\n      return {\n        used,\n        available: estimated - used,\n        percentage: Math.min(percentage, 100),\n      };\n    } catch {\n      return { used: 0, available: 0, percentage: 0 };\n    }\n  }\n\n  /**\n   * Get full key with prefix\n   */\n  private getFullKey(key: string): string {\n    return `${this.prefix}:${key}`;\n  }\n}\n\n/**\n * Player-specific storage manager\n */\nexport class PlayerStorageManager {\n  private storage: StorageManager;\n  private readonly stateKey = 'playerState';\n\n  constructor(storage?: StorageManager, prefix = 'ytMusicPlayer') {\n    this.storage = storage || new LocalStorageManager(prefix);\n  }\n\n  /**\n   * Save complete player state\n   */\n  saveState(state: PlayerStateData): void {\n    try {\n      // Create a serializable version of the state\n      const serializableState = {\n        ...state,\n        lastUpdated: state.lastUpdated.toISOString(),\n        playlist: {\n          ...state.playlist,\n          tracks: state.playlist.tracks.map(track => ({\n            ...track,\n            addedAt: track.addedAt.toISOString(),\n          })),\n        },\n      };\n\n      this.storage.save(this.stateKey, serializableState);\n    } catch (error) {\n      console.warn('Failed to save player state:', error);\n    }\n  }\n\n  /**\n   * Load complete player state\n   */\n  loadState(): PlayerStateData | null {\n    try {\n      const state = this.storage.load<any>(this.stateKey);\n      if (!state) {\n        return null;\n      }\n\n      // Convert string dates back to Date objects\n      return {\n        ...state,\n        lastUpdated: new Date(state.lastUpdated),\n        playlist: {\n          ...state.playlist,\n          tracks: state.playlist.tracks.map((track: any) => ({\n            ...track,\n            addedAt: new Date(track.addedAt),\n          })),\n        },\n      };\n    } catch (error) {\n      console.warn('Failed to load player state:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Save only playlist data\n   */\n  savePlaylist(playlist: PlayerStateData['playlist']): void {\n    try {\n      const state = this.loadState();\n      if (state) {\n        state.playlist = playlist;\n        state.lastUpdated = new Date();\n        this.saveState(state);\n      }\n    } catch (error) {\n      console.warn('Failed to save playlist:', error);\n    }\n  }\n\n  /**\n   * Save only current playback position\n   */\n  saveCurrentTime(currentTime: number): void {\n    try {\n      const state = this.loadState();\n      if (state) {\n        state.currentTime = currentTime;\n        state.lastUpdated = new Date();\n        this.saveState(state);\n      }\n    } catch (error) {\n      console.warn('Failed to save current time:', error);\n    }\n  }\n\n  /**\n   * Save only player settings\n   */\n  saveSettings(settings: PlayerStateData['settings']): void {\n    try {\n      const state = this.loadState();\n      if (state) {\n        state.settings = settings;\n        state.lastUpdated = new Date();\n        this.saveState(state);\n      }\n    } catch (error) {\n      console.warn('Failed to save settings:', error);\n    }\n  }\n\n  /**\n   * Clear all stored data\n   */\n  clearState(): void {\n    try {\n      this.storage.remove(this.stateKey);\n    } catch (error) {\n      console.warn('Failed to clear player state:', error);\n    }\n  }\n\n  /**\n   * Check if storage is available\n   */\n  isStorageAvailable(): boolean {\n    if (this.storage instanceof LocalStorageManager) {\n      return this.storage.isAvailable();\n    }\n    return true; // Assume other storage implementations are available\n  }\n\n  /**\n   * Migrate data from old format to new format\n   */\n  migrateData(oldKey = 'ytMusicPlayer'): boolean {\n    try {\n      const oldData = localStorage.getItem(oldKey);\n      if (!oldData) {\n        return false;\n      }\n\n      const parsed = JSON.parse(oldData);\n      \n      // Convert old format to new format if needed\n      if (parsed && typeof parsed === 'object') {\n        // This is where you'd handle migration logic\n        // For now, we'll assume the format is compatible\n        this.storage.save(this.stateKey, parsed);\n        localStorage.removeItem(oldKey);\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      console.warn('Failed to migrate data:', error);\n      return false;\n    }\n  }\n}\n\n// Default export\nexport const defaultStorage = new PlayerStorageManager(); ","import {\n  YTPlayer,\n  PlayerState,\n  RepeatMode,\n  Track,\n  Playlist,\n  PlayerSettings,\n  PlayerStateData,\n  PlayerEventType,\n  EventHandler,\n  PlayerConfig,\n  VideoInfo,\n  PlayerError,\n  ErrorType,\n  YouTubePlayerOptions,\n} from '../types';\nimport { \n  extractVideoId, \n  youtubeAPI, \n  getThumbnailUrl, \n  formatTime,\n  createPlayerError,\n  generateShuffleOrder,\n  debounce\n} from '../utils/youtube';\nimport { PlayerStorageManager, defaultStorage } from '../utils/storage';\n\n/**\n * Main YouTube Music Player class\n */\nexport class YouTubeMusicPlayer {\n  private player: YTPlayer | null = null;\n  private playlist: Playlist = {\n    tracks: [],\n    currentIndex: 0,\n    shuffled: false,\n  };\n  private settings: PlayerSettings = {\n    volume: 80,\n    repeatMode: RepeatMode.ALL,\n    shuffled: false,\n    autoplay: false,\n  };\n  private currentTime = 0;\n  private isReady = false;\n  private containerId: string;\n  private storage: PlayerStorageManager;\n  private eventListeners: Map<PlayerEventType, EventHandler[]> = new Map();\n  \n  // Debounced functions\n  private debouncedSaveState: () => void;\n  private debouncedTimeUpdate: () => void;\n\n  constructor(config: PlayerConfig) {\n    this.containerId = config.containerId;\n    this.storage = config.saveState !== false ? defaultStorage : new PlayerStorageManager();\n    \n    // Apply config\n    if (config.volume !== undefined) this.settings.volume = config.volume;\n    if (config.repeat !== undefined) this.settings.repeatMode = config.repeat;\n    if (config.shuffle !== undefined) this.settings.shuffled = config.shuffle;\n    if (config.autoplay !== undefined) this.settings.autoplay = config.autoplay;\n\n    // Setup debounced functions\n    this.debouncedSaveState = debounce(() => this.saveCurrentState(), 1000);\n    this.debouncedTimeUpdate = debounce(() => this.debouncedSaveState(), 2000);\n\n    // Initialize\n    this.initialize();\n  }\n\n  /**\n   * Initialize the player\n   */\n  private async initialize(): Promise<void> {\n    try {\n      // Load stored state\n      this.loadStoredState();\n\n      // Wait for YouTube API\n      await youtubeAPI.waitForReady();\n\n      // Create player container if it doesn't exist\n      this.ensureContainer();\n\n      // Create YouTube player\n      this.createPlayer();\n\n      this.emit('ready', { player: this });\n    } catch (error) {\n      this.handleError({\n        type: ErrorType.API_ERROR,\n        message: 'Failed to initialize player',\n        originalError: error,\n      });\n    }\n  }\n\n  /**\n   * Ensure player container exists\n   */\n  private ensureContainer(): void {\n    let container = document.getElementById(this.containerId);\n    if (!container) {\n      container = document.createElement('div');\n      container.id = this.containerId;\n      container.style.cssText = 'width: 0; height: 0; overflow: hidden; position: absolute;';\n      document.body.appendChild(container);\n    }\n  }\n\n  /**\n   * Create YouTube player instance\n   */\n  private createPlayer(): void {\n    const playerOptions: YouTubePlayerOptions = {\n      height: 0,\n      width: 0,\n      playerVars: {\n        autoplay: 0,\n        controls: 0,\n        disablekb: 1,\n        enablejsapi: 1,\n        iv_load_policy: 3,\n        modestbranding: 1,\n        playsinline: 1,\n        rel: 0,\n        origin: window.location.origin, // Fix for localhost CORS issues\n      },\n      events: {\n        onReady: (event) => this.handlePlayerReady(event),\n        onStateChange: (event) => this.handlePlayerStateChange(event),\n        onError: (event) => this.handlePlayerError(event),\n      },\n    };\n\n    this.player = new window.YT.Player(this.containerId, playerOptions);\n  }\n\n  /**\n   * Handle player ready event\n   */\n  private handlePlayerReady(event: any): void {\n    this.isReady = true;\n    this.player?.setVolume(this.settings.volume);\n\n    // Start monitoring time updates\n    this.startTimeMonitoring();\n\n    // Load current track if available\n    if (this.playlist.tracks.length > 0) {\n      this.loadCurrentTrack();\n    }\n\n    this.emit('ready', { player: this });\n  }\n\n  /**\n   * Handle player state changes\n   */\n  private handlePlayerStateChange(event: any): void {\n    const state = event.data;\n    \n    this.emit('stateChange', { \n      state, \n      isPlaying: state === PlayerState.PLAYING,\n      isPaused: state === PlayerState.PAUSED,\n      isEnded: state === PlayerState.ENDED,\n    });\n\n    // Handle track end\n    if (state === PlayerState.ENDED) {\n      this.handleTrackEnded();\n    }\n\n    // Save state when playing starts\n    if (state === PlayerState.PLAYING) {\n      this.debouncedSaveState();\n    }\n  }\n\n  /**\n   * Handle YouTube API errors\n   */\n  private handlePlayerError(event: any): void {\n    const errorCode = event.data;\n    const currentTrack = this.getCurrentTrack();\n    const error = createPlayerError(errorCode, currentTrack?.id);\n    \n    this.handleError(error);\n\n    // Try to skip to next track on certain errors\n    if ([100, 101, 150].includes(errorCode) && this.playlist.tracks.length > 1) {\n      this.next();\n    }\n  }\n\n  /**\n   * Handle track ended\n   */\n  private handleTrackEnded(): void {\n    if (this.settings.repeatMode === RepeatMode.ONE) {\n      // Repeat current track\n      this.seekTo(0);\n      this.play();\n    } else {\n      // Move to next track\n      this.next();\n    }\n  }\n\n  /**\n   * Start time monitoring\n   */\n  private startTimeMonitoring(): void {\n    const updateTime = () => {\n      if (this.player && this.isReady) {\n        this.currentTime = this.player.getCurrentTime();\n        this.handleTimeUpdate();\n      }\n      requestAnimationFrame(updateTime);\n    };\n    updateTime();\n  }\n\n  /**\n   * Handle time updates\n   */\n  private handleTimeUpdate(): void {\n    this.emit('timeUpdate', {\n      currentTime: this.currentTime,\n      duration: this.getDuration(),\n      progress: this.getProgress(),\n    });\n    \n    // Save position occasionally (debounced)\n    this.debouncedTimeUpdate();\n  }\n\n  /**\n   * Add a track to the playlist\n   */\n  async addTrack(url: string, title?: string): Promise<Track | null> {\n    const validation = extractVideoId(url);\n    if (!validation.isValid || !validation.videoId) {\n      this.handleError({\n        type: ErrorType.INVALID_VIDEO_ID,\n        message: 'Invalid YouTube URL',\n      });\n      return null;\n    }\n\n    const track: Track = {\n      id: validation.videoId,\n      title: title || `Video ${validation.videoId}`,\n      duration: 0, // Will be updated when video loads\n      thumbnail: getThumbnailUrl(validation.videoId),\n      url,\n      addedAt: new Date(),\n    };\n\n    this.playlist.tracks.push(track);\n    \n    // If this is the first track, load it\n    if (this.playlist.tracks.length === 1) {\n      this.playlist.currentIndex = 0;\n      this.loadCurrentTrack();\n    }\n\n    this.emit('playlistChange', { \n      playlist: this.playlist,\n      action: 'add',\n      track,\n    });\n\n    this.debouncedSaveState();\n    return track;\n  }\n\n  /**\n   * Add a track with enhanced metadata\n   */\n  async addTrackWithMetadata(trackData: {\n    id: string;\n    title: string;\n    artist?: string;\n    tags?: string[];\n  }): Promise<Track | null> {\n    const track: Track = {\n      id: trackData.id,\n      title: trackData.title,\n      artist: trackData.artist,\n      tags: trackData.tags,\n      duration: 0, // Will be fetched from YouTube when the video loads\n      thumbnail: getThumbnailUrl(trackData.id),\n      url: `https://youtu.be/${trackData.id}`,\n      addedAt: new Date(),\n    };\n\n    this.playlist.tracks.push(track);\n    \n    // If this is the first track, load it\n    if (this.playlist.tracks.length === 1) {\n      this.playlist.currentIndex = 0;\n      this.loadCurrentTrack();\n    }\n\n    this.emit('playlistChange', { \n      playlist: this.playlist,\n      action: 'add',\n      track,\n    });\n\n    this.debouncedSaveState();\n    return track;\n  }\n\n  /**\n   * Remove track from playlist\n   */\n  removeTrack(index: number): boolean {\n    if (index < 0 || index >= this.playlist.tracks.length) {\n      return false;\n    }\n\n    const removedTrack = this.playlist.tracks[index];\n    this.playlist.tracks.splice(index, 1);\n\n    // Adjust current index\n    if (index < this.playlist.currentIndex) {\n      this.playlist.currentIndex--;\n    } else if (index === this.playlist.currentIndex) {\n      // Current track was removed\n      if (this.playlist.tracks.length === 0) {\n        this.playlist.currentIndex = 0;\n        this.stop();\n      } else {\n        // Load next track (or previous if at end)\n        if (this.playlist.currentIndex >= this.playlist.tracks.length) {\n          this.playlist.currentIndex = 0;\n        }\n        this.loadCurrentTrack();\n      }\n    }\n\n    this.emit('playlistChange', { \n      playlist: this.playlist,\n      action: 'remove',\n      track: removedTrack,\n      index,\n    });\n\n    this.debouncedSaveState();\n    return true;\n  }\n\n  /**\n   * Load current track into player\n   */\n  private loadCurrentTrack(): void {\n    const track = this.getCurrentTrack();\n    if (!track || !this.player || !this.isReady) {\n      return;\n    }\n\n    this.player.loadVideoById(track.id, this.currentTime);\n    \n    this.emit('trackChange', {\n      track,\n      index: this.playlist.currentIndex,\n      playlist: this.playlist,\n    });\n  }\n\n  /**\n   * Play current track\n   */\n  play(): void {\n    if (this.player && this.isReady) {\n      this.player.playVideo();\n    }\n  }\n\n  /**\n   * Pause current track\n   */\n  pause(): void {\n    if (this.player && this.isReady) {\n      this.player.pauseVideo();\n    }\n  }\n\n  /**\n   * Stop playback\n   */\n  stop(): void {\n    if (this.player && this.isReady) {\n      this.player.stopVideo();\n      this.currentTime = 0;\n    }\n  }\n\n  /**\n   * Toggle play/pause\n   */\n  togglePlay(): void {\n    if (!this.player || !this.isReady) return;\n\n    const state = this.player.getPlayerState();\n    if (state === PlayerState.PLAYING) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n\n  /**\n   * Go to next track\n   */\n  next(): void {\n    if (this.playlist.tracks.length === 0) return;\n\n    let nextIndex: number;\n\n    if (this.settings.shuffled && this.playlist.shuffleOrder) {\n      // Find current position in shuffle order\n      const currentShufflePos = this.playlist.shuffleOrder.indexOf(this.playlist.currentIndex);\n      const nextShufflePos = (currentShufflePos + 1) % this.playlist.shuffleOrder.length;\n      nextIndex = this.playlist.shuffleOrder[nextShufflePos];\n    } else {\n      nextIndex = (this.playlist.currentIndex + 1) % this.playlist.tracks.length;\n    }\n\n    this.jumpToTrack(nextIndex);\n  }\n\n  /**\n   * Go to previous track\n   */\n  previous(): void {\n    if (this.playlist.tracks.length === 0) return;\n\n    let prevIndex: number;\n\n    if (this.settings.shuffled && this.playlist.shuffleOrder) {\n      // Find current position in shuffle order\n      const currentShufflePos = this.playlist.shuffleOrder.indexOf(this.playlist.currentIndex);\n      const prevShufflePos = currentShufflePos === 0 \n        ? this.playlist.shuffleOrder.length - 1 \n        : currentShufflePos - 1;\n      prevIndex = this.playlist.shuffleOrder[prevShufflePos];\n    } else {\n      prevIndex = this.playlist.currentIndex === 0 \n        ? this.playlist.tracks.length - 1 \n        : this.playlist.currentIndex - 1;\n    }\n\n    this.jumpToTrack(prevIndex);\n  }\n\n  /**\n   * Jump to specific track\n   */\n  jumpToTrack(index: number): void {\n    if (index < 0 || index >= this.playlist.tracks.length) return;\n\n    this.playlist.currentIndex = index;\n    this.currentTime = 0;\n    this.loadCurrentTrack();\n    \n    if (this.settings.autoplay) {\n      this.play();\n    }\n  }\n\n  /**\n   * Seek to position in current track\n   */\n  seekTo(seconds: number): void {\n    if (this.player && this.isReady) {\n      this.player.seekTo(seconds);\n      this.currentTime = seconds;\n    }\n  }\n\n  /**\n   * Set volume (0-100)\n   */\n  setVolume(volume: number): void {\n    volume = Math.max(0, Math.min(100, volume));\n    this.settings.volume = volume;\n    \n    if (this.player && this.isReady) {\n      this.player.setVolume(volume);\n    }\n\n    this.emit('volumeChange', { volume });\n    this.debouncedSaveState();\n  }\n\n  /**\n   * Mute/unmute\n   */\n  toggleMute(): void {\n    if (!this.player || !this.isReady) return;\n\n    if (this.player.isMuted()) {\n      this.player.unMute();\n    } else {\n      this.player.mute();\n    }\n  }\n\n  /**\n   * Toggle shuffle mode\n   */\n  toggleShuffle(): void {\n    this.settings.shuffled = !this.settings.shuffled;\n    \n    if (this.settings.shuffled) {\n      this.playlist.shuffleOrder = generateShuffleOrder(\n        this.playlist.tracks.length,\n        this.playlist.currentIndex\n      );\n    } else {\n      this.playlist.shuffleOrder = undefined;\n    }\n\n    this.emit('settingsChange', { settings: this.settings });\n    this.debouncedSaveState();\n  }\n\n  /**\n   * Cycle through repeat modes\n   */\n  toggleRepeat(): void {\n    const modes = [RepeatMode.NONE, RepeatMode.ALL, RepeatMode.ONE];\n    const currentIndex = modes.indexOf(this.settings.repeatMode);\n    const nextIndex = (currentIndex + 1) % modes.length;\n    \n    this.settings.repeatMode = modes[nextIndex];\n    \n    this.emit('settingsChange', { settings: this.settings });\n    this.debouncedSaveState();\n  }\n\n  /**\n   * Clear playlist\n   */\n  clearPlaylist(): void {\n    this.playlist.tracks = [];\n    this.playlist.currentIndex = 0;\n    this.playlist.shuffleOrder = undefined;\n    this.stop();\n\n    this.emit('playlistChange', { \n      playlist: this.playlist,\n      action: 'clear',\n    });\n\n    this.debouncedSaveState();\n  }\n\n  // Getters\n  getCurrentTrack(): Track | null {\n    return this.playlist.tracks[this.playlist.currentIndex] || null;\n  }\n\n  getPlaylist(): Playlist {\n    return { ...this.playlist };\n  }\n\n  getSettings(): PlayerSettings {\n    return { ...this.settings };\n  }\n\n  getCurrentTime(): number {\n    return this.currentTime;\n  }\n\n  getDuration(): number {\n    return this.player?.getDuration() || 0;\n  }\n\n  getProgress(): number {\n    const duration = this.getDuration();\n    return duration > 0 ? (this.currentTime / duration) * 100 : 0;\n  }\n\n  getVolume(): number {\n    return this.settings.volume;\n  }\n\n  isPlaying(): boolean {\n    return this.player?.getPlayerState() === PlayerState.PLAYING;\n  }\n\n  isPaused(): boolean {\n    return this.player?.getPlayerState() === PlayerState.PAUSED;\n  }\n\n  isMuted(): boolean {\n    return this.player?.isMuted() || false;\n  }\n\n  // Event handling\n  on(event: PlayerEventType, handler: EventHandler): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)?.push(handler);\n  }\n\n  off(event: PlayerEventType, handler: EventHandler): void {\n    const handlers = this.eventListeners.get(event);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  private emit(event: PlayerEventType, data: any): void {\n    const handlers = this.eventListeners.get(event);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.warn('Event handler error:', error);\n        }\n      });\n    }\n  }\n\n  private handleError(error: PlayerError): void {\n    console.error('Player error:', error);\n    this.emit('error', error);\n  }\n\n  // State persistence\n  private saveCurrentState(): void {\n    if (!this.storage) return;\n\n    const state: PlayerStateData = {\n      playlist: this.playlist,\n      currentTime: this.currentTime,\n      settings: this.settings,\n      lastUpdated: new Date(),\n    };\n\n    this.storage.saveState(state);\n  }\n\n  /**\n   * Check if playlist has been initialized with tracks\n   */\n  hasInitializedPlaylist(): boolean {\n    return this.playlist.tracks.length > 0;\n  }\n\n  private loadStoredState(): void {\n    if (!this.storage) return;\n\n    const state = this.storage.loadState();\n    if (state) {\n      this.playlist = state.playlist;\n      this.currentTime = state.currentTime;\n      this.settings = state.settings;\n    }\n  }\n\n  /**\n   * Destroy player and clean up\n   */\n  destroy(): void {\n    if (this.player) {\n      this.player.destroy();\n      this.player = null;\n    }\n    \n    this.eventListeners.clear();\n    this.isReady = false;\n  }\n} ","\n        import { YouTubeMusicPlayer, RepeatMode } from './src/index.ts';\n        \n        let player;\n        let isPlaylistOpen = false;\n        \n        // Available playlists\n        const availablePlaylists = [\n            { id: 'remote', name: '💀 Finest Music', file: 'playlist-remote.json', default: true },\n            { id: 'bangers', name: '🔥 Bangers', file: 'playlist-bangers.json' },\n            { id: 'mash', name: '🎵 Mash', file: 'playlist-mash.json' }\n        ];\n        \n        // Find default playlist (fallback to first one)\n        const defaultPlaylist = availablePlaylists.find(p => p.default) || availablePlaylists[0];\n        let currentPlaylistId = defaultPlaylist.id;\n\n        // Load tracklist from JSON file\n        async function loadTracklist(playlistFile = null) {\n            try {\n                const file = playlistFile || availablePlaylists.find(p => p.id === currentPlaylistId)?.file || 'playlist-bangers.json';\n                const response = await fetch(`./${file}`);\n                const tracklist = await response.json();\n                return tracklist;\n            } catch (error) {\n                console.error('Failed to load tracklist:', error);\n                return [];\n            }\n        }\n\n        // Calculate simple hash of tracklist for change detection\n        function calculateTracklistHash(tracklist) {\n            const str = JSON.stringify(tracklist.map(t => ({ id: t.id, title: t.title, artist: t.artist })));\n            let hash = 0;\n            for (let i = 0; i < str.length; i++) {\n                const char = str.charCodeAt(i);\n                hash = ((hash << 5) - hash) + char;\n                hash = hash & hash; // Convert to 32-bit integer\n            }\n            return hash.toString();\n        }\n\n        // Check if tracklist has changed and clear storage if needed\n        async function checkTracklistChanges() {\n            try {\n                const tracklist = await loadTracklist();\n                const currentHash = calculateTracklistHash(tracklist);\n                const storageKey = `ytMusicPlayer:tracklistHash:${currentPlaylistId}`;\n                const storedHash = localStorage.getItem(storageKey);\n                \n                if (storedHash && storedHash !== currentHash) {\n                    // Tracklist changed, clear stored data\n                    console.log('Tracklist changed, clearing stored data...');\n                    localStorage.removeItem('ytMusicPlayer:playerState');\n                    localStorage.setItem(storageKey, currentHash);\n                    return true; // Indicates data was cleared\n                } else if (!storedHash) {\n                    // First time, store hash\n                    localStorage.setItem(storageKey, currentHash);\n                }\n                \n                return false; // No changes\n            } catch (error) {\n                console.error('Failed to check tracklist changes:', error);\n                return false;\n            }\n        }\n\n        // Switch to a different playlist\n        async function switchPlaylist(playlistId) {\n            if (playlistId === currentPlaylistId) return;\n            \n            try {\n                updateStatus('🔄 Switching playlist...');\n                \n                // Update current playlist\n                currentPlaylistId = playlistId;\n                \n                // Clear current playlist\n                player.clearPlaylist();\n                \n                // Load new tracklist\n                await loadInitialTracks();\n                \n                // Update UI\n                updateUI();\n                updatePlaylistSelector();\n                \n                const playlistName = availablePlaylists.find(p => p.id === playlistId)?.name || 'Unknown';\n                updateStatus(`✅ Switched to ${playlistName}!`);\n                \n                // Update URL to reflect playlist change\n                updateBrowserURL();\n                \n                // Save session immediately on playlist change\n                saveSession();\n                \n                // Handle track parameter if present (after playlist switch)\n                if (window.urlTrackParam) {\n                    setTimeout(() => {\n                        jumpToTrackByName(window.urlTrackParam);\n                        delete window.urlTrackParam;\n                    }, 500);\n                }\n                \n            } catch (error) {\n                updateStatus('❌ Failed to switch playlist');\n                console.error('Failed to switch playlist:', error);\n            }\n        }\n\n        // Update playlist selector to reflect current playlist\n        function updatePlaylistSelector() {\n            const selector = document.getElementById('playlistSelector');\n            if (selector) {\n                selector.value = currentPlaylistId;\n            }\n        }\n        \n        // Initialize player\n        async function initPlayer() {\n            try {\n                // Check if tracklist changed and clear storage if needed\n                const tracklistChanged = await checkTracklistChanges();\n                if (tracklistChanged) {\n                    updateStatus('📋 Tracklist updated, loading new tracks...');\n                }\n\n                player = new YouTubeMusicPlayer({\n                    containerId: 'youtube-player',\n                    autoplay: false,\n                    volume: 100, // Full volume - users control via system/browser\n                    saveState: true\n                });\n\n                // Set up event listeners\n                player.on('ready', async () => {\n                    updateStatus('🎉 Player ready!');\n                    \n                    // Check build version and show notification if needed\n                    checkBuildVersion();\n                    \n                    // Handle URL parameters first (they take priority over session restore)\n                    await handleURLParameters();\n                    // Note: CORS errors from doubleclick.net are normal (YouTube ads) and can be ignored\n                    \n                    // Only load initial tracks if no playlist exists (prevent duplicates on reload)\n                    if (!player.hasInitializedPlaylist()) {\n                        updateStatus('🎉 Player ready! Loading tracks...');\n                        await loadInitialTracks();\n                    } else {\n                        updateStatus('🎉 Player ready! Playlist loaded from storage.');\n                    }\n                    \n                    updateUI();\n                    \n                    // Handle track parameter if present (after playlist is loaded)\n                    if (window.urlTrackParam) {\n                        setTimeout(() => {\n                            jumpToTrackByName(window.urlTrackParam);\n                            delete window.urlTrackParam;\n                        }, 500); // Small delay to ensure playlist is fully loaded\n                    }\n                    \n                    // Restore session if no URL parameters were provided\n                    if (!window.location.search) {\n                        setTimeout(async () => {\n                            await restoreSession();\n                        }, 1500);\n                    }\n                    \n                    // Update URL to reflect initial state (after small delay)\n                    setTimeout(() => {\n                        updateBrowserURL();\n                    }, 2000);\n                });\n\n                player.on('trackChange', (data) => {\n                    updateCurrentTrack(data.track);\n                    updatePlaylist();\n                    // Update URL to reflect track change\n                    updateBrowserURL();\n                    // Save session immediately on track change\n                    saveSession();\n                });\n\n                player.on('stateChange', (data) => {\n                    updatePlayButton(data.isPlaying);\n                    updateStatusIndicator(data.isPlaying, data.isPaused);\n                    if (data.isPlaying) {\n                        updateStatus('▶ Playing...');\n                    } else if (data.isPaused) {\n                        updateStatus('⏸ Paused');\n                    }\n                });\n\n                player.on('timeUpdate', (data) => {\n                    updateProgress(data.currentTime, data.duration);\n                    // Save progress with 30-second throttling\n                    saveProgressThrottled();\n                });\n\n                player.on('playlistChange', () => {\n                    updatePlaylist();\n                });\n\n                player.on('settingsChange', () => {\n                    updateSettingsButtons();\n                    // Save session immediately on settings change\n                    saveSession();\n                });\n\n                player.on('error', (error) => {\n                    updateStatus(`❌ Error: ${error.message}`);\n                    console.error('Player error:', error);\n                });\n\n            } catch (error) {\n                updateStatus(`❌ Failed to initialize player: ${error.message}`);\n                console.error('Initialization error:', error);\n            }\n        }\n\n        // Load initial tracks from JSON\n        async function loadInitialTracks() {\n            try {\n                const tracklist = await loadTracklist();\n                let addedCount = 0;\n                \n                for (const trackData of tracklist) {\n                    try {\n                        const track = await player.addTrackWithMetadata(trackData);\n                        if (track) {\n                            addedCount++;\n                        }\n                    } catch (error) {\n                        console.warn('Failed to add track:', trackData, error);\n                    }\n                }\n                \n                updateStatus(`✅ Loaded ${addedCount} tracks from tracklist!`);\n            } catch (error) {\n                updateStatus('❌ Failed to load initial tracks');\n                console.error('Failed to load initial tracks:', error);\n            }\n        }\n\n        // UI Functions\n        function updateStatus(message) {\n            console.log(message);\n        }\n\n        function updateStatusIndicator(isPlaying, isPaused) {\n            const indicator = document.getElementById('statusIndicator');\n            if (isPlaying) {\n                indicator.className = 'w-3 h-3 bg-green-400 rounded-full animate-pulse-dot';\n            } else if (isPaused) {\n                indicator.className = 'w-3 h-3 bg-yellow-400 rounded-full';\n            } else {\n                indicator.className = 'w-3 h-3 bg-gray-400 rounded-full';\n            }\n        }\n\n        // Handle album art load (simplified - always square)\n        function handleAlbumArtLoad(img) {\n            console.log(`Album art loaded: ${img.naturalWidth}x${img.naturalHeight}`);\n            showAlbumArt(true);\n        }\n\n        // Show/hide album art based on load success\n        function showAlbumArt(success) {\n            const albumArt = document.getElementById('albumArt');\n            const placeholder = document.getElementById('albumArtPlaceholder');\n            const overlay = document.getElementById('albumArtOverlay');\n            \n            if (success) {\n                albumArt.classList.remove('hidden');\n                placeholder.classList.add('hidden');\n                overlay.classList.remove('hidden');\n            } else {\n                // Randomly select one of the placeholder images (0-3)\n                const randomIndex = Math.floor(Math.random() * 4);\n                placeholder.src = `./placeholder_${randomIndex}.png`;\n                \n                albumArt.classList.add('hidden');\n                placeholder.classList.remove('hidden');\n                overlay.classList.add('hidden');\n            }\n        }\n\n        // Update album art with YouTube thumbnail\n        function updateAlbumArt(videoId) {\n            if (!videoId) {\n                showAlbumArt(false);\n                return;\n            }\n            \n            const albumArt = document.getElementById('albumArt');\n            \n            // Try different thumbnail qualities for better results\n            // maxresdefault (1280x720) -> hqdefault (480x360) -> mqdefault (320x180)\n            const thumbnailUrls = [\n                `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,\n                `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,\n                `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`\n            ];\n            \n            // Try loading the highest quality first\n            tryLoadThumbnail(albumArt, thumbnailUrls, 0);\n        }\n\n        // Recursively try loading thumbnails from highest to lowest quality\n        function tryLoadThumbnail(imgElement, urls, index) {\n            if (index >= urls.length) {\n                // All URLs failed, show fallback\n                showAlbumArt(false);\n                return;\n            }\n            \n            // Create a temporary image to test loading\n            const testImg = new Image();\n            testImg.onload = function() {\n                // Success - use this URL\n                imgElement.src = urls[index];\n            };\n            testImg.onerror = function() {\n                // Failed - try next URL\n                tryLoadThumbnail(imgElement, urls, index + 1);\n            };\n            testImg.src = urls[index];\n        }\n\n        function updateCurrentTrack(track) {\n            const titleElement = document.getElementById('trackTitle');\n            const infoElement = document.getElementById('trackInfo');\n            \n            if (track) {\n                // Display: [artist] - [title]\n                if (track.artist) {\n                    titleElement.textContent = `${track.artist} - ${track.title}`;\n                } else {\n                    titleElement.textContent = track.title;\n                }\n                \n                // Display tags\n                if (track.tags && track.tags.length > 0) {\n                    infoElement.textContent = track.tags.join(', ');\n                } else {\n                    infoElement.textContent = `Video ID: ${track.id}`;\n                }\n                \n                // Update album art\n                updateAlbumArt(track.id);\n            } else {\n                titleElement.textContent = 'No track loaded';\n                infoElement.textContent = 'Select a track to start playing';\n                showAlbumArt(false);\n            }\n        }\n\n        function updatePlayButton(isPlaying) {\n            const playIcon = document.getElementById('playIcon');\n            const pauseIcon = document.getElementById('pauseIcon');\n            \n            if (isPlaying) {\n                playIcon.classList.add('hidden');\n                pauseIcon.classList.remove('hidden');\n            } else {\n                playIcon.classList.remove('hidden');\n                pauseIcon.classList.add('hidden');\n            }\n        }\n\n        function updateProgress(currentTime, duration) {\n            const progressFill = document.getElementById('progressFill');\n            const currentTimeEl = document.getElementById('currentTime');\n            const durationEl = document.getElementById('duration');\n            \n            const progress = duration > 0 ? (currentTime / duration) * 100 : 0;\n            progressFill.style.width = progress + '%';\n            \n            currentTimeEl.textContent = formatTime(currentTime);\n            durationEl.textContent = formatTime(duration);\n        }\n\n        function updatePlaylist() {\n            const trackList = document.getElementById('trackList');\n            const trackCount = document.getElementById('trackCount');\n            const playlist = player.getPlaylist();\n            \n            trackCount.textContent = playlist.tracks.length;\n            \n            if (playlist.tracks.length === 0) {\n                trackList.innerHTML = `\n                    <div class=\"flex items-center justify-center p-8 text-gray-500\">\n                        <div class=\"text-center\">\n                            <svg class=\"w-12 h-12 mx-auto mb-2 text-gray-300\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                                <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3\"/>\n                            </svg>\n                            <p class=\"text-sm\">Loading tracks...</p>\n                        </div>\n                    </div>\n                `;\n                return;\n            }\n            \n            trackList.innerHTML = playlist.tracks.map((track, index) => {\n                const isCurrent = index === playlist.currentIndex;\n                \n                let artist = '';\n                if (track.artist) {\n                    artist = track.artist;\n                } else if (track.tags && track.tags.length > 0) {\n                    artist = track.tags.slice(0, 2).join(', ');\n                }\n                \n                const duration = track.duration > 0 ? formatTime(track.duration) : '';\n                \n                return `\n                    <div class=\"playlist-item p-4 cursor-pointer ${isCurrent ? 'active' : ''}\" onclick=\"jumpToTrack(${index})\">\n                        <div class=\"flex items-center gap-3\">\n                            <div class=\"w-8 h-8 flex items-center justify-center\">\n                                ${isCurrent ? `\n                                    <div class=\"w-4 h-4 bg-red-500 rounded-full flex items-center justify-center\">\n                                        <div class=\"w-2 h-2 bg-white rounded-full animate-pulse-dot\"></div>\n                                    </div>\n                                ` : `\n                                    <svg class=\"w-4 h-4 text-gray-400\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                                        <path d=\"M8 5v14l11-7z\"/>\n                                    </svg>\n                                `}\n                            </div>\n                            <div class=\"flex-1 min-w-0\">\n                                <h4 class=\"track-title font-medium text-sm truncate ${isCurrent ? 'text-red-600' : 'text-gray-900'}\">${track.title}</h4>\n                                <p class=\"text-xs text-gray-500 truncate\">${artist}</p>\n                            </div>\n                            ${duration ? `<span class=\"text-xs text-gray-400\">${duration}</span>` : ''}\n                        </div>\n                    </div>\n                `;\n            }).join('');\n        }\n\n        function updateSettingsButtons() {\n            const settings = player.getSettings();\n            const shuffleBtn = document.getElementById('shuffleBtn');\n            const repeatBtn = document.getElementById('repeatBtn');\n            \n            // Update shuffle button\n            if (settings.shuffled) {\n                shuffleBtn.classList.add('text-red-500');\n                shuffleBtn.classList.remove('text-gray-600');\n            } else {\n                shuffleBtn.classList.add('text-gray-600');\n                shuffleBtn.classList.remove('text-red-500');\n            }\n            \n            // Update repeat button\n            if (settings.repeatMode !== RepeatMode.NONE) {\n                repeatBtn.classList.add('text-red-500');\n                repeatBtn.classList.remove('text-gray-600');\n            } else {\n                repeatBtn.classList.add('text-gray-600');\n                repeatBtn.classList.remove('text-red-500');\n            }\n        }\n\n        function updateUI() {\n            updatePlaylist();\n            updateSettingsButtons();\n            updateCurrentTrack(player.getCurrentTrack());\n            updatePlaylistSelector();\n        }\n\n        function formatTime(seconds) {\n            if (isNaN(seconds) || seconds < 0) return '0:00';\n            const mins = Math.floor(seconds / 60);\n            const secs = Math.floor(seconds % 60);\n            return `${mins}:${secs.toString().padStart(2, '0')}`;\n        }\n\n        // Control Functions\n        window.togglePlay = function() {\n            player.togglePlay();\n        };\n\n        window.switchPlaylist = switchPlaylist;\n\n        window.next = function() {\n            player.next();\n        };\n\n        window.previous = function() {\n            player.previous();\n        };\n\n        window.seek = function(event) {\n            const progressBar = event.currentTarget;\n            const rect = progressBar.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const percentage = x / rect.width;\n            const duration = player.getDuration();\n            const seekTime = percentage * duration;\n            \n            player.seekTo(seekTime);\n        };\n\n        window.toggleShuffle = function() {\n            player.toggleShuffle();\n        };\n\n        window.toggleRepeat = function() {\n            player.toggleRepeat();\n        };\n\n        window.jumpToTrack = function(index) {\n            player.jumpToTrack(index);\n        };\n\n        window.togglePlaylist = function() {\n            const panel = document.getElementById('playlistPanel');\n            isPlaylistOpen = !isPlaylistOpen;\n            \n            if (isPlaylistOpen) {\n                panel.classList.remove('hidden');\n            } else {\n                panel.classList.add('hidden');\n            }\n        };\n\n        window.toggleLike = function() {\n            const track = player.getCurrentTrack();\n            if (track) {\n                const youtubeUrl = `https://www.youtube.com/watch?v=${track.id}`;\n                window.open(youtubeUrl, '_blank');\n            }\n        };\n\n        window.copyTrackInfo = function() {\n            const track = player.getCurrentTrack();\n            if (track) {\n                const youtubeUrl = `https://www.youtube.com/watch?v=${track.id}`;\n                navigator.clipboard.writeText(youtubeUrl).then(() => {\n                    console.log('📋 YouTube URL copied to clipboard!');\n                }).catch(err => {\n                    console.error('Failed to copy to clipboard:', err);\n                });\n            }\n        };\n\n        // Video mode toggle functionality\n        let isVideoMode = localStorage.getItem('ytMusicPlayer:videoMode') === 'true';\n        \n        window.toggleVideoMode = function() {\n            isVideoMode = !isVideoMode;\n            const body = document.body;\n            const videoOffIcon = document.getElementById('videoOffIcon');\n            const videoOnIcon = document.getElementById('videoOnIcon');\n            \n            if (isVideoMode) {\n                body.classList.add('video-mode');\n                videoOffIcon.classList.add('hidden');\n                videoOnIcon.classList.remove('hidden');\n                console.log('🎬 Video mode enabled');\n            } else {\n                body.classList.remove('video-mode');\n                videoOffIcon.classList.remove('hidden');\n                videoOnIcon.classList.add('hidden');\n                console.log('🖼️ Album art mode enabled');\n            }\n            \n            // Save preference\n            localStorage.setItem('ytMusicPlayer:videoMode', isVideoMode.toString());\n            \n            // Update URL to reflect video mode change\n            updateBrowserURL();\n        };\n        \n        // Initialize video mode state\n        function initVideoMode() {\n            if (isVideoMode) {\n                toggleVideoMode();\n            }\n        }\n\n        // Parse URL parameters for deep linking\n        function parseURLParameters() {\n            const urlParams = new URLSearchParams(window.location.search);\n            return {\n                playlist: urlParams.get('playlist'),\n                track: urlParams.get('track'), \n                video: urlParams.get('video') === 'true'\n            };\n        }\n\n        // Handle URL parameters for deep linking\n        async function handleURLParameters() {\n            const params = parseURLParameters();\n            \n            // Handle video mode parameter\n            if (params.video && !isVideoMode) {\n                console.log('🎬 Enabling video mode from URL parameter');\n                toggleVideoMode();\n            }\n            \n            // Handle playlist parameter\n            if (params.playlist) {\n                const playlistExists = availablePlaylists.find(p => p.id === params.playlist);\n                if (playlistExists && params.playlist !== currentPlaylistId) {\n                    console.log(`📋 Loading playlist from URL: ${params.playlist}`);\n                    await switchPlaylist(params.playlist);\n                }\n            }\n            \n            // Handle track parameter - will be implemented after playlist loads\n            if (params.track) {\n                // Store for later use when playlist is ready\n                window.urlTrackParam = params.track;\n            }\n        }\n\n        // Jump to track by name or ID (for URL parameter)\n        function jumpToTrackByName(trackIdentifier) {\n            const playlist = player.getPlaylist();\n            if (!playlist || !playlist.tracks.length) {\n                console.warn('No playlist loaded for track jump');\n                return false;\n            }\n            \n            // Try to find track by title (case insensitive) or by video ID\n            const trackIndex = playlist.tracks.findIndex(track => \n                track.title.toLowerCase().includes(trackIdentifier.toLowerCase()) ||\n                track.id === trackIdentifier ||\n                (track.artist && `${track.artist} - ${track.title}`.toLowerCase().includes(trackIdentifier.toLowerCase()))\n            );\n            \n            if (trackIndex !== -1) {\n                console.log(`🎵 Jumping to track: ${playlist.tracks[trackIndex].title}`);\n                player.jumpToTrack(trackIndex);\n                return true;\n            } else {\n                console.warn(`Track not found: ${trackIdentifier}`);\n                return false;\n            }\n        }\n\n        // Update browser URL to reflect current state\n        function updateBrowserURL() {\n            const currentTrack = player?.getCurrentTrack();\n            const params = new URLSearchParams();\n            \n            // Add playlist parameter if not default\n            if (currentPlaylistId !== defaultPlaylist.id) {\n                params.set('playlist', currentPlaylistId);\n            }\n            \n            // Add track parameter if a track is playing\n            if (currentTrack && currentTrack.title) {\n                // Use a sanitized version of the track title for readability\n                const trackParam = currentTrack.title\n                    .toLowerCase()\n                    .replace(/[^a-z0-9\\s]/g, '') // Remove special characters\n                    .replace(/\\s+/g, '-') // Replace spaces with dashes\n                    .substring(0, 50); // Limit length\n                params.set('track', trackParam);\n            }\n            \n            // Add video parameter if video mode is enabled\n            if (isVideoMode) {\n                params.set('video', 'true');\n            }\n            \n            // Build the new URL\n            const baseUrl = window.location.pathname;\n            const queryString = params.toString();\n            const newUrl = queryString ? `${baseUrl}?${queryString}` : baseUrl;\n            \n            // Update the URL without reloading the page\n            window.history.replaceState({}, '', newUrl);\n        }\n\n        // Enhanced Session Management System\n        const SESSION_KEY = 'ytPlayer:session';\n        const BUILD_TIME_KEY = 'ytPlayer:buildTime';\n        let lastProgressSave = 0; // Timestamp of last progress save\n        let sessionData = {};\n\n        // Save session data to localStorage\n        function saveSession() {\n            try {\n                const currentTrack = player?.getCurrentTrack();\n                const playlist = player?.getPlaylist();\n                const settings = player?.getSettings();\n                \n                sessionData = {\n                    playlist: currentPlaylistId,\n                    track: currentTrack?.id || null,\n                    shuffle: settings?.shuffled || false,\n                    repeat: settings?.repeatMode || 'none',\n                    video: isVideoMode,\n                    progress: player?.getCurrentTime() || 0,\n                    volume: player?.getVolume() || 100,\n                    lastSaved: Date.now()\n                };\n                \n                localStorage.setItem(SESSION_KEY, JSON.stringify(sessionData));\n                console.log('💾 Session saved');\n            } catch (error) {\n                console.warn('Failed to save session:', error);\n            }\n        }\n\n        // Save progress with 30-second throttling\n        function saveProgressThrottled() {\n            const now = Date.now();\n            if (now - lastProgressSave >= 30000) { // 30 seconds\n                lastProgressSave = now;\n                saveSession();\n            }\n        }\n\n        // Load session data from localStorage\n        function loadSession() {\n            try {\n                const stored = localStorage.getItem(SESSION_KEY);\n                if (stored) {\n                    return JSON.parse(stored);\n                }\n            } catch (error) {\n                console.warn('Failed to load session:', error);\n            }\n            return null;\n        }\n\n        // Restore session state\n        async function restoreSession() {\n            const session = loadSession();\n            if (!session) {\n                console.log('No session to restore');\n                return;\n            }\n\n            console.log('🔄 Restoring session...', session);\n\n            try {\n                // Restore playlist if different\n                if (session.playlist && session.playlist !== currentPlaylistId) {\n                    await switchPlaylist(session.playlist);\n                }\n\n                // Wait for playlist to load\n                await new Promise(resolve => setTimeout(resolve, 500));\n\n                // Restore track\n                if (session.track) {\n                    const playlist = player.getPlaylist();\n                    const trackIndex = playlist.tracks.findIndex(track => track.id === session.track);\n                    if (trackIndex !== -1) {\n                        player.jumpToTrack(trackIndex);\n                        \n                        // Restore progress after track loads\n                        setTimeout(() => {\n                            if (session.progress > 0) {\n                                player.seekTo(session.progress);\n                                console.log(`⏱️ Restored progress: ${Math.floor(session.progress)}s`);\n                            }\n                        }, 1000);\n                    }\n                }\n\n                // Restore settings\n                if (session.shuffle !== undefined) {\n                    const currentSettings = player.getSettings();\n                    if (currentSettings.shuffled !== session.shuffle) {\n                        player.toggleShuffle();\n                    }\n                }\n\n                // Restore video mode\n                if (session.video !== isVideoMode) {\n                    toggleVideoMode();\n                }\n\n                console.log('✅ Session restored successfully');\n            } catch (error) {\n                console.warn('Failed to restore session:', error);\n            }\n        }\n\n        // Build notification system\n        function checkBuildVersion() {\n            try {\n                const currentBuildTime = document.querySelector('meta[name=\"build-time\"]')?.content;\n                if (!currentBuildTime) {\n                    console.log('No build time found in meta tag');\n                    return;\n                }\n\n                const storedBuildTime = localStorage.getItem(BUILD_TIME_KEY);\n                const dismissKey = `ytPlayer:buildDismissed:${currentBuildTime}`;\n                const isDismissed = localStorage.getItem(dismissKey) === 'true';\n\n                if (storedBuildTime && storedBuildTime !== currentBuildTime && !isDismissed) {\n                    showBuildNotification(currentBuildTime);\n                }\n\n                // Always update stored build time\n                localStorage.setItem(BUILD_TIME_KEY, currentBuildTime);\n            } catch (error) {\n                console.warn('Failed to check build version:', error);\n            }\n        }\n\n        function showBuildNotification(buildTime) {\n            const notification = document.getElementById('buildNotification');\n            const notificationText = document.getElementById('buildNotificationText');\n            \n            notificationText.textContent = `${buildTime} New version available - more bangers, more tracks`;\n            \n            // Show notification\n            setTimeout(() => {\n                notification.classList.add('show');\n                document.body.classList.add('notification-shown');\n            }, 500);\n        }\n\n        window.dismissBuildNotification = function() {\n            const notification = document.getElementById('buildNotification');\n            const currentBuildTime = document.querySelector('meta[name=\"build-time\"]')?.content;\n            \n            // Hide notification\n            notification.classList.remove('show');\n            document.body.classList.remove('notification-shown');\n            \n            // Mark as dismissed for this build\n            if (currentBuildTime) {\n                localStorage.setItem(`ytPlayer:buildDismissed:${currentBuildTime}`, 'true');\n            }\n        };\n\n        // Make album art functions globally available for HTML callbacks\n        window.showAlbumArt = showAlbumArt;\n        window.handleAlbumArtLoad = handleAlbumArtLoad;\n\n        // Initialize player when page loads\n        initPlayer();\n        initVideoMode();\n    "],"names":["PlayerState","RepeatMode","ErrorType","getThumbnailUrl","videoId","quality","default","medium","high","standard","maxres","youtubeAPI","constructor","this","state","loaded","loading","loadPromise","callbacks","loadAPI","Promise","resolve","reject","window","YT","Player","originalCallback","onYouTubeIframeAPIReady","forEach","callback","script","document","createElement","src","onerror","error","Error","firstScript","getElementsByTagName","parentNode","insertBefore","head","appendChild","setTimeout","isReady","waitForReady","push","getState","debounce","func","wait","timeout","args","clearTimeout","LocalStorageManager","prefix","save","key","data","serialized","JSON","stringify","fullKey","getFullKey","localStorage","setItem","console","warn","load","item","getItem","parse","remove","removeItem","clear","keysToRemove","i","length","startsWith","isAvailable","testKey","getUsageInfo","used","available","percentage","value","estimated","Math","min","PlayerStorageManager","storage","stateKey","saveState","serializableState","lastUpdated","toISOString","playlist","tracks","map","track","addedAt","loadState","Date","savePlaylist","saveCurrentTime","currentTime","saveSettings","settings","clearState","isStorageAvailable","migrateData","oldKey","oldData","parsed","defaultStorage","YouTubeMusicPlayer","config","player","currentIndex","shuffled","volume","repeatMode","ALL","autoplay","eventListeners","Map","containerId","repeat","shuffle","debouncedSaveState","saveCurrentState","debouncedTimeUpdate","initialize","loadStoredState","ensureContainer","createPlayer","emit","handleError","type","API_ERROR","message","originalError","container","getElementById","id","style","cssText","body","playerOptions","height","width","playerVars","controls","disablekb","enablejsapi","iv_load_policy","modestbranding","playsinline","rel","origin","location","events","onReady","event","handlePlayerReady","onStateChange","handlePlayerStateChange","onError","handlePlayerError","_a","setVolume","startTimeMonitoring","loadCurrentTrack","isPlaying","PLAYING","isPaused","PAUSED","isEnded","ENDED","handleTrackEnded","errorCode","currentTrack","getCurrentTrack","errorInfo","INVALID_VIDEO_ID","VIDEO_NOT_FOUND","VIDEO_NOT_EMBEDDABLE","createPlayerError","includes","next","ONE","seekTo","play","updateTime","getCurrentTime","handleTimeUpdate","requestAnimationFrame","duration","getDuration","progress","getProgress","addTrack","url","title","validation","patterns","cleanUrl","trim","pattern","match","isValid","extractVideoId","thumbnail","action","addTrackWithMetadata","trackData","artist","tags","removeTrack","index","removedTrack","splice","stop","loadVideoById","playVideo","pause","pauseVideo","stopVideo","togglePlay","getPlayerState","nextIndex","shuffleOrder","nextShufflePos","indexOf","jumpToTrack","previous","prevIndex","currentShufflePos","prevShufflePos","seconds","max","toggleMute","isMuted","unMute","mute","toggleShuffle","order","Array","from","_","j","floor","random","currentPos","generateShuffleOrder","toggleRepeat","modes","NONE","clearPlaylist","getPlaylist","getSettings","getVolume","on","handler","has","set","get","off","handlers","hasInitializedPlaylist","destroy","isPlaylistOpen","availablePlaylists","name","file","defaultPlaylist","find","p","currentPlaylistId","async","loadTracklist","playlistFile","response","fetch","json","checkTracklistChanges","currentHash","tracklist","str","t","hash","charCodeAt","toString","calculateTracklistHash","storageKey","storedHash","log","switchPlaylist","playlistId","updateStatus","loadInitialTracks","updateUI","updatePlaylistSelector","updateBrowserURL","saveSession","urlTrackParam","jumpToTrackByName","selector","addedCount","showAlbumArt","success","albumArt","placeholder","overlay","classList","add","randomIndex","updateAlbumArt","tryLoadThumbnail","imgElement","urls","testImg","Image","onload","updateCurrentTrack","titleElement","infoElement","textContent","join","updatePlaylist","trackList","trackCount","innerHTML","isCurrent","slice","formatTime","updateSettingsButtons","shuffleBtn","repeatBtn","isNaN","padStart","seek","rect","currentTarget","getBoundingClientRect","seekTime","clientX","left","togglePlaylist","panel","toggleLike","youtubeUrl","open","copyTrackInfo","navigator","clipboard","writeText","then","catch","err","isVideoMode","trackIdentifier","trackIndex","findIndex","toLowerCase","params","URLSearchParams","trackParam","replace","substring","baseUrl","pathname","queryString","newUrl","history","replaceState","toggleVideoMode","videoOffIcon","videoOnIcon","SESSION_KEY","BUILD_TIME_KEY","lastProgressSave","sessionData","video","lastSaved","now","dismissBuildNotification","notification","currentBuildTime","querySelector","content","handleAlbumArtLoad","img","naturalWidth","naturalHeight","storedBuildTime","dismissKey","isDismissed","buildTime","showBuildNotification","checkBuildVersion","urlParams","search","parseURLParameters","handleURLParameters","session","stored","loadSession","restoreSession","playIcon","pauseIcon","updatePlayButton","indicator","className","updateStatusIndicator","progressFill","currentTimeEl","durationEl","updateProgress","saveProgressThrottled","initPlayer"],"mappings":"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"}